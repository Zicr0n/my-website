import{h as p,j as b,k as a,l as m}from"./scheduler.DZprM1kE.js";import{B as v,l as w,C as g,k as x}from"./index.DCUrm-tw.js";import{H as E}from"./control.CYgJF_JY.js";function B(e,t){const n=t.token={};function r(c,s,_,k){if(t.token!==n)return;t.resolved=k;let u=t.ctx;_!==void 0&&(u=u.slice(),u[_]=k);const l=c&&(t.current=c)(u);let d=!1;t.block&&(t.blocks?t.blocks.forEach((h,o)=>{o!==s&&h&&(v(),w(h,1,1,()=>{t.blocks[o]===h&&(t.blocks[o]=null)}),g())}):t.block.d(1),l.c(),x(l,1),l.m(t.mount(),t.anchor),d=!0),t.block=l,t.blocks&&(t.blocks[s]=l),d&&m()}if(p(e)){const c=b();if(e.then(s=>{a(c),r(t.then,1,t.value,s),a(null)},s=>{if(a(c),r(t.catch,2,t.error,s),a(null),!t.hasCatch)throw s}),t.current!==t.pending)return r(t.pending,0),!0}else{if(t.current!==t.then)return r(t.then,1,t.value,e),!0;t.resolved=e}}function T(e,t,n){const r=t.slice(),{resolved:c}=e;e.current===e.then&&(r[e.value]=c),e.current===e.catch&&(r[e.error]=c),e.block.p(r,n)}function q(e,t){throw new E(e,t)}new TextEncoder;export{q as e,B as h,T as u};
